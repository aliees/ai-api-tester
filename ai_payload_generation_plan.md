# AI Payload Generation Feature Plan

This document outlines the plan for implementing the "AI Payload Generation" feature.

## 1. Feature Overview

The goal is to add a feature that allows users to enter a text prompt, which is then sent to an AI service to generate a JSON payload for a test case. This will simplify the process of creating complex JSON bodies for API requests.

## 2. AI Microservice (`ai-microservice/app.py`)

A new endpoint will be added to the AI microservice to handle payload generation.

### New Endpoint: `/generate-payload`

-   **Route:** `/generate-payload`
-   **Method:** `POST`
-   **Description:** Receives a text prompt and uses an AI model to generate a JSON payload.

### Request Body

The endpoint will expect a JSON object with the following structure:

```json
{
  "prompt": "Your text prompt here. For example: 'Create a user with a name, email, and a nested address object with city and zip code.'"
}
```

-   `prompt` (string, required): The text prompt from the user describing the desired JSON payload.

### Success Response (200 OK)

The endpoint will return a JSON object with the generated payload:

```json
{
  "payload": {
    "user": {
      "name": "John Doe",
      "email": "john.doe@example.com",
      "address": {
        "city": "New York",
        "zipcode": "10001"
      }
    }
  }
}
```

-   `payload` (object): The JSON payload generated by the AI.

### Error Response (e.g., 500 Internal Server Error)

If an error occurs during generation, the response will be:

```json
{
  "error": "A description of the error."
}
```

### Implementation Details

-   The new endpoint will use the OpenAI API (e.g., `gpt-3.5-turbo` or a newer model) to generate the payload.
-   The prompt sent to the AI will be simple, like: `Generate a JSON object based on the following description: [user's prompt]. Only return the JSON object.`
-   Error handling will be implemented for cases where the AI service fails or returns invalid JSON.

## 3. Frontend (`frontend/src/components/ApiForm.tsx`)

The frontend will be updated to include the new UI elements and logic for interacting with the `/generate-payload` endpoint.

### UI Changes

1.  **AI Prompt Input Field:**
    -   A new `textarea` will be added below the `Request Body (JSON)` text area.
    -   **Label:** "Generate Body with AI Prompt"
    -   **Placeholder:** "e.g., Create a JSON payload for a new user with a name and email."

2.  **"Generate with AI" Button:**
    -   A new button will be added next to the AI prompt input field.
    -   **Label:** "Generate with AI"
    -   This button will be disabled while a request to the AI service is in progress.

### Logic

1.  **State Management:**
    -   A new state variable, `aiPrompt`, will be added to the `ApiForm` component to hold the value of the AI prompt input field.
    -   A new loading state, `isGeneratingPayload`, will be added to track the status of the AI generation request.

2.  **Event Handling:**
    -   The `onChange` event of the new input field will update the `aiPrompt` state.
    -   The `onClick` event of the "Generate with AI" button will trigger the `handleGeneratePayload` function.

3.  **`handleGeneratePayload` Function:**
    -   This asynchronous function will be created inside the `ApiForm` component.
    -   It will perform the following steps:
        1.  Set `isGeneratingPayload` to `true`.
        2.  Make a `POST` request to the `http://localhost:5001/generate-payload` endpoint.
        3.  The request body will be `{"prompt": aiPrompt}`.
        4.  On a successful response, it will take the `payload` from the response, stringify it with proper indentation (`JSON.stringify(data.payload, null, 2)`), and update the `body` state using `setBody()`.
        5.  In case of an error, it will display an alert or a notification to the user.
        6.  Finally, it will set `isGeneratingPayload` to `false`.

### Component Structure (Pseudo-code)

```tsx
const ApiForm = ({...}) => {
  // ... existing states
  const [body, setBody] = useState('');
  const [aiPrompt, setAiPrompt] = useState('');
  const [isGeneratingPayload, setIsGeneratingPayload] = useState(false);

  const handleGeneratePayload = async () => {
    if (!aiPrompt) {
      alert('Please enter a prompt.');
      return;
    }
    setIsGeneratingPayload(true);
    try {
      const response = await fetch('http://localhost:5001/generate-payload', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ prompt: aiPrompt }),
      });
      const data = await response.json();
      if (response.ok) {
        setBody(JSON.stringify(data.payload, null, 2));
      } else {
        throw new Error(data.error || 'Failed to generate payload.');
      }
    } catch (error) {
      console.error(error);
      alert(error.message);
    }
    setIsGeneratingPayload(false);
  };

  return (
    // ... existing form
    <label htmlFor="body">Request Body (JSON)</label>
    <TextareaAutosize
      id="body"
      value={body}
      onChange={(e) => setBody(e.target.value)}
      // ...
    />

    <label htmlFor="ai-prompt">Generate Body with AI Prompt</label>
    <textarea
      id="ai-prompt"
      value={aiPrompt}
      onChange={(e) => setAiPrompt(e.target.value)}
      placeholder="e.g., Create a JSON payload for a new user..."
    />
    <button type="button" onClick={handleGeneratePayload} disabled={isGeneratingPayload}>
      {isGeneratingPayload ? 'Generating...' : 'Generate with AI'}
    </button>
    
    // ... rest of the form
  );
};
```

## 4. Workflow Diagram

Here is a Mermaid diagram illustrating the workflow:

```mermaid
sequenceDiagram
    participant User
    participant Frontend as ApiForm.tsx
    participant AI Microservice as app.py
    participant OpenAI

    User->>Frontend: Enters prompt in "AI Prompt" field
    User->>Frontend: Clicks "Generate with AI"
    Frontend->>AI Microservice: POST /generate-payload with { "prompt": "..." }
    AI Microservice->>OpenAI: Requests JSON generation from prompt
    OpenAI-->>AI Microservice: Returns generated JSON
    AI Microservice-->>Frontend: Returns { "payload": { ... } }
    Frontend->>Frontend: Populates "Request Body (JSON)" with payload
    User->>Frontend: Sees the generated JSON in the body field